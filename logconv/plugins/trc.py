
import os
import shutil
from logconv.model import LogFormatPlugin, FormatCapabilities, LogDocument, WriteResult, BusType, TimeBase


class TrcPlugin(LogFormatPlugin):
    name = "trc"
    extensions = [".trc"]

    def capabilities(self) -> FormatCapabilities:
        return FormatCapabilities(supports_streaming=True, supports_signals=False, bus_types=[BusType.CAN])

    def detect(self, path: str, sample: bytes = None) -> bool:
        # Extension match first
        if path and any(path.lower().endswith(ext) for ext in self.extensions):
            return True
        # Simple sniff: TRC has header line ;$FILEVERSION=
        if sample:
            return b";$FILEVERSION" in sample
        return False

    def parse(self, path, options=None) -> LogDocument:
        meta = {"path": path, "format": "trc"}
        try:
            with open(path, "rb") as f:
                data = f.read()
            meta["raw_bytes"] = data
            try:
                meta["raw_text"] = data.decode("utf-8", errors="ignore")
            except Exception:
                pass
        except Exception:
            meta["raw_bytes"] = b""
        # Currently passthrough (frames not decoded). Warn user on write.
        return LogDocument(source_info=meta, bus_type=BusType.CAN, time_base=TimeBase.REL_NS, frames=[], metadata=meta)

    def write(self, path, log_doc: LogDocument, options=None) -> WriteResult:
        try:
            if log_doc.frames:
                # Encode frames into a simple TRC-like text output
                lines = []
                lines.append(";$FILEVERSION=1.3")
                lines.append("; Generated by logconv")
                lines.append(";   Message Number")
                lines.append(";   |         Time Offset (ms)")
                lines.append(";   |         |        Type")
                lines.append(";   |         |        |        ID (hex)")
                lines.append(";   |         |        |        |     Data Length")
                lines.append(";   |         |        |        |     |   Data Bytes (hex) ...")
                lines.append(";---+--   ----+----  --+--  ----+---  +  -+ -- -- -- -- -- -- --")
                base_ns = log_doc.frames[0].timestamp_ns if log_doc.frames else 0
                for idx, fr in enumerate(log_doc.frames, start=1):
                    t_ms = (fr.timestamp_ns - base_ns) / 1_000_000.0
                    direction = "Rx" if fr.direction.lower().startswith("r") else "Tx"
                    arb = fr.arbitration_id
                    dlc = fr.dlc
                    data_str = " ".join(f"{b:02X}" for b in fr.payload[:dlc])
                    lines.append(f"{idx:6d}) {t_ms:11.1f}  {direction:2s}     {arb:08X}  {dlc:1d}  {data_str}")
                with open(path, "w", encoding="utf-8") as f:
                    f.write("\n".join(lines))
                return WriteResult(success=True, output_paths=[path], warnings=[])

            raw_bytes = log_doc.metadata.get("raw_bytes")
            raw_text = log_doc.metadata.get("raw_text")
            if raw_bytes is not None:
                with open(path, "wb") as f:
                    f.write(raw_bytes)
            elif raw_text is not None:
                with open(path, "w", encoding="utf-8") as f:
                    f.write(raw_text)
            else:
                # Fallback: copy source file if present
                src = (log_doc.source_info or {}).get("path")
                if src and os.path.exists(src):
                    shutil.copyfile(src, path)
                else:
                    with open(path, "w", encoding="utf-8") as f:
                        f.write("# trc export\n")
            warnings = ["TRC plugin performed raw passthrough (frames not re-encoded)."]
            return WriteResult(success=True, output_paths=[path], warnings=warnings)
        except Exception as e:
            return WriteResult(success=False, messages=[str(e)])


plugin = TrcPlugin()
