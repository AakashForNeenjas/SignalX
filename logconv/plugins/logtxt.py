import re
from logconv.model import (
    LogFormatPlugin,
    FormatCapabilities,
    LogDocument,
    WriteResult,
    BusType,
    TimeBase,
    Frame,
)


class LogTxtPlugin(LogFormatPlugin):
    """
    Best-effort parser for BUSMASTER-style ASCII logs.
    Format (per line):
    <Time><Tx/Rx><Channel><CAN ID><Type><DLC><DataBytes>
    e.g. 17:55:10:3004 Rx 1 0x1A7 s 8 00 00 9C 18 08 00 44 16
    """

    name = "log"
    extensions = [".log", ".txt"]

    def capabilities(self) -> FormatCapabilities:
        return FormatCapabilities(supports_streaming=False, supports_signals=False, bus_types=[BusType.CAN, BusType.CUSTOM])

    def detect(self, path: str, sample: bytes = None) -> bool:
        if path and any(path.lower().endswith(ext) for ext in self.extensions):
            return True
        if sample:
            sniff = sample.lower()
            return b"busmaster" in sniff or b"start logging" in sniff
        return False

    def parse(self, path, options=None) -> LogDocument:
        meta = {"path": path, "format": "logtxt"}
        frames = []
        first_ts_ms = None
        time_re = re.compile(r"^(\d{2}):(\d{2}):(\d{2}):(\d+)")
        try:
            with open(path, "r", encoding="utf-8", errors="ignore") as f:
                for line in f:
                    line = line.strip()
                    if not line or line.startswith("***"):
                        continue
                    m = time_re.match(line)
                    if not m:
                        continue
                    try:
                        hh, mm, ss, sub = m.groups()
                        t_ms = (
                            int(hh) * 3600000
                            + int(mm) * 60000
                            + int(ss) * 1000
                            + int(sub)
                        )
                        if first_ts_ms is None:
                            first_ts_ms = t_ms
                        t_rel_ms = t_ms - first_ts_ms
                    except Exception:
                        continue
                    parts = line.split()
                    if len(parts) < 7:
                        continue
                    direction = parts[1].lower()
                    arb_str = parts[3]
                    try:
                        arb_id = int(arb_str, 16) if arb_str.lower().startswith("0x") else int(arb_str)
                    except Exception:
                        continue
                    try:
                        dlc = int(parts[5])
                    except Exception:
                        dlc = max(0, len(parts) - 6)
                    data_bytes = []
                    for b in parts[6:6 + dlc]:
                        try:
                            data_bytes.append(int(b, 16))
                        except Exception:
                            break
                    payload = bytes(data_bytes[:dlc])
                    frames.append(
                        Frame(
                            timestamp_ns=int(t_rel_ms * 1_000_000),
                            arbitration_id=arb_id,
                            dlc=dlc,
                            payload=payload,
                            direction="rx" if "rx" in direction else "tx",
                            channel=parts[2] if len(parts) > 2 else None,
                            id_format="extended" if arb_id > 0x7FF else "standard",
                        )
                    )
        except Exception:
            meta["parse_warning"] = "Failed to parse lines; fallback to raw passthrough."

        meta["frame_count"] = len(frames)
        if first_ts_ms is not None:
            meta["start_ms"] = first_ts_ms

        if frames:
            return LogDocument(
                source_info=meta,
                bus_type=BusType.CAN,
                time_base=TimeBase.REL_NS,
                frames=frames,
                metadata=meta,
            )

        # Fallback: raw passthrough if no frames parsed
        try:
            with open(path, "rb") as f:
                data = f.read()
            meta["raw_bytes"] = data
            try:
                meta["raw_text"] = data.decode("utf-8", errors="ignore")
            except Exception:
                pass
        except Exception:
            meta["raw_bytes"] = b""

        return LogDocument(source_info=meta, bus_type=BusType.CUSTOM, time_base=TimeBase.REL_NS, frames=[], metadata=meta)

    def write(self, path, log_doc: LogDocument, options=None) -> WriteResult:
        try:
            if log_doc.frames:
                # Emit as simple BUSMASTER-like text
                lines = []
                lines.append("*** GENERATED BY logconv (text) ***")
                lines.append("***<Time><Tx/Rx><Channel><CAN ID><Type><DLC><DataBytes>***")
                for fr in log_doc.frames:
                    t_ms = fr.timestamp_ns / 1_000_000.0
                    hh = int(t_ms // 3600000) % 24
                    mm = int((t_ms % 3600000) // 60000)
                    ss = int((t_ms % 60000) // 1000)
                    sub = int(t_ms % 1000)
                    direction = "Rx" if fr.direction.lower().startswith("r") else "Tx"
                    canid = f"0x{fr.arbitration_id:X}"
                    dlc = fr.dlc
                    data_str = " ".join(f"{b:02X}" for b in fr.payload[:dlc])
                    lines.append(f"{hh:02d}:{mm:02d}:{ss:02d}:{sub:03d} {direction} {fr.channel or 1} {canid} s {dlc} {data_str}")
                with open(path, "w", encoding="utf-8") as f:
                    f.write("\n".join(lines))
                return WriteResult(success=True, output_paths=[path], warnings=["Exported as text; metadata may differ from original log."])

            raw_bytes = log_doc.metadata.get("raw_bytes")
            raw_text = log_doc.metadata.get("raw_text")
            if raw_bytes is not None:
                with open(path, "wb") as f:
                    f.write(raw_bytes)
            elif raw_text is not None:
                with open(path, "w", encoding="utf-8") as f:
                    f.write(raw_text)
            else:
                with open(path, "w", encoding="utf-8") as f:
                    f.write("# generic log export\n")
            warnings = ["LOG/TXT plugin performed raw passthrough (frames not re-encoded)."]
            return WriteResult(success=True, output_paths=[path], warnings=warnings)
        except Exception as e:
            return WriteResult(success=False, messages=[str(e)])


plugin = LogTxtPlugin()
